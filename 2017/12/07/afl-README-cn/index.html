<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>afl-README-cn | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转载：http://blog.csdn.net/abcdyzhang/article/details/53727221 AFL-简介fuzzing 是漏洞挖掘领域最有效的方法之一，可以用来发现大量内存错误漏洞。然而fuzzing 的优势是相对肤浅和盲目的，随意变异使得我们很难实现达到程序特定的代码路径。这就使得测试的代码覆盖率很低。 有人试图去解决这个问题，Tavis曾经提出一种：语料精馏法。这个">
<meta property="og:type" content="article">
<meta property="og:title" content="afl-README-cn">
<meta property="og:url" content="http://yoursite.com/2017/12/07/afl-README-cn/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="转载：http://blog.csdn.net/abcdyzhang/article/details/53727221 AFL-简介fuzzing 是漏洞挖掘领域最有效的方法之一，可以用来发现大量内存错误漏洞。然而fuzzing 的优势是相对肤浅和盲目的，随意变异使得我们很难实现达到程序特定的代码路径。这就使得测试的代码覆盖率很低。 有人试图去解决这个问题，Tavis曾经提出一种：语料精馏法。这个">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2017-12-07T16:40:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="afl-README-cn">
<meta name="twitter:description" content="转载：http://blog.csdn.net/abcdyzhang/article/details/53727221 AFL-简介fuzzing 是漏洞挖掘领域最有效的方法之一，可以用来发现大量内存错误漏洞。然而fuzzing 的优势是相对肤浅和盲目的，随意变异使得我们很难实现达到程序特定的代码路径。这就使得测试的代码覆盖率很低。 有人试图去解决这个问题，Tavis曾经提出一种：语料精馏法。这个">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-afl-README-cn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/07/afl-README-cn/" class="article-date">
  <time datetime="2017-12-07T15:56:43.000Z" itemprop="datePublished">2017-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      afl-README-cn
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载：<a href="http://blog.csdn.net/abcdyzhang/article/details/53727221" target="_blank" rel="noopener">http://blog.csdn.net/abcdyzhang/article/details/53727221</a></p>
<h1 id="AFL-简介"><a href="#AFL-简介" class="headerlink" title="AFL-简介"></a>AFL-简介</h1><pre><code>fuzzing 是漏洞挖掘领域最有效的方法之一，可以用来发现大量内存错误漏洞。然而fuzzing 的优势是相对肤浅和盲目的，随意变异使得我们很难实现达到程序特定的代码路径。这就使得测试的代码覆盖率很低。
有人试图去解决这个问题，Tavis曾经提出一种：语料精馏法。这个方法更具代码覆盖率，从大量高质量的输入文件语料中选取一个子集，然后按照传统的方法去Fuzz。这种方法很有效，但前提是需要一个这样的语料。另一方面，代码覆盖率只是提供了一个很简单的对程序状态的描述，当Fuzzing测试到了一定程度，代码覆盖率就没什么作用了。
所以，大家在探索更复杂的技术，比如：程序控制流分析，符号执行或静态分析。这些技术在实验中是很有前途的，但是在实际应用中显得效率底下，缺乏可靠性。
</code></pre><h2 id="AFL的方案"><a href="#AFL的方案" class="headerlink" title="AFL的方案"></a>AFL的方案</h2><p>   AFL是一个暴力方法的fuzzer，采用了一个极其简单但是绝对可靠的，插桩代码导向的遗传算法。<br>   它使用一种自定义的边缘覆盖率来识别程序控制流的局部变化。<br>   简单来说，整个算法的逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) Load user-supplied initial test cases into the queue,</span><br><span class="line">- 2) Take next input file from the queue,</span><br><span class="line">3) Attempt to trim the test case to the smallest size that doesn&apos;t alter</span><br><span class="line">   the measured behavior of the program,</span><br><span class="line">4) Repeatedly mutate the file using a balanced and well-researched variety</span><br><span class="line">   of traditional fuzzing strategies,</span><br><span class="line">5) If any of the generated mutations resulted in a new state transition</span><br><span class="line">   recorded by the instrumentation, add mutated output as a new entry in the</span><br><span class="line">   queue.</span><br><span class="line">6) Go to 2.</span><br></pre></td></tr></table></figure></p>
<pre><code>被选择出来的测试用例会进行周期性的删减，消除哪些已经被更新的，更高覆盖率的废弃的测试用例。
整个fuzing过程，会产生一个很有用的测试集合的语料库，可以用来对一些浏览器、office应用、不开源的软件进行压力测试。
经测试。AFL的性能比blind fuzzing 或者 coverage-only 工具高多了。
</code></pre><h2 id="使用AFL插桩程序"><a href="#使用AFL插桩程序" class="headerlink" title="使用AFL插桩程序"></a>使用AFL插桩程序</h2><pre><code>有源码的时候，我们可以在编译期间进行instrument.这种instrument对性能影响很小。
gcc/g++ 重新源码编译的方法是：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=/path/to/afl/afl-gcc ./configure</span><br><span class="line">make clean all</span><br></pre></td></tr></table></figure>

C++需要多加一个 `CXX=/path/to/afl-g++`
afl-clang 和afl-clang++ 使用方法类似。clang 用户还可以选择更高效的插桩模式参考llvm_mode
当测试一个lib的时候，我们需要写一个小程序，把stdin中的或者一个文件中读取数据，然后传入到被测试的lib里。这种情况下，我们必须把插好桩的库的静态版本和可执行文件链接起来。或者确保运行时加载正确.so文件。最简单的方法就是静态构建。方法如下；
`CC=/path/to/afl/afl-gcc ./configure –disable-shared`
*如果设置AFL_HARDEN=1，当调用‘make’时会导致CC自动启动代码hardening选项，使得检测内存bug更简单。Libdislocator，是AFL的一个辅助库（在Libdislocator/README.dislocator中），可以帮助发现heap corruption堆溢出问题。*
</code></pre><h2 id="对无源码的二进制插桩"><a href="#对无源码的二进制插桩" class="headerlink" title="对无源码的二进制插桩"></a>对无源码的二进制插桩</h2><pre><code>AFL对没有源代码的程序提供的黑盒二进制instrument支持是实验性的。通过qemu的用户级(userland)仿真实现。
QEMU是独立于AFL的工程，但是在AFL中也提供了便于实现该功能的方式：
$ cd qemu_mode
$ ./build_qemu_support.sh
更多的说明和注意事项，在qemu_mode/README.qemu中。
这种模式比编译时instrument慢2到5倍，而且不利于并行处理。
所以最好还是对有源码的fuzzing吧
</code></pre><h2 id="开始Fuzzing"><a href="#开始Fuzzing" class="headerlink" title="开始Fuzzing"></a>开始Fuzzing</h2><p>afl-fuzz负责进行fuzzing的过程，需要指定一个初始test cases的输入目录、一个存放findings结构的输出目录和要测试的目标程序的路径。<br>对那些可以直接从stdin读取输入的目标程序来说，语法如下：<br>$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]<br>对从文件读取输入的目标程序来说，要用“@@”，语法如下：<br>$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@<br>也可以用-f选项，把变异数据写到一个指定的文件。<br>对于没有被instrument的二进制目标程序，可以用qemu模式(-Q)进行fuzz，或者直接用传统blind-fuzzer模式（-n）。<br>使用-t和-m选项，修改fuzz过程的默认timeout和memory limit。<br>一般afl-fuzz在开始时会执行一系列的确定性fuzzing步骤，这会花费几天的时间，但是会生成更neat的testcase。如果你想要快速运行、马上生成dirty的结果—-类似于zzuf和其他传统fuzzer—-可以使用-d选项，跳过确定性fuzzing步骤。</p>
<h2 id="fuzzing的输出文件说明"><a href="#fuzzing的输出文件说明" class="headerlink" title="fuzzing的输出文件说明"></a>fuzzing的输出文件说明</h2><p>有关如何解释显示的统计信息和监视进程的运行状况的信息，请参阅status_screen.txt文件。<br>Fuzzing过程中，会在输出目录中创建3个子目录并实时更新：</p>
<ul>
<li>queue/ - 每个独特执行路径的test case，加上用户给定的初始文件。这就是the synthesized corpus合成语料库。可以使用afl-cmin缩小size。</li>
<li>crashes/ - 导致程序接收fatal信号(e.g., SIGSEGV, SIGILL, SIGABRT)的unique test case。会根据信号的不同进行分组。</li>
<li>hangs/ - unique test cases that cause the tested program to time out.<br>如果相关联的执行路径包含在先前记录的故障中未见到的任何状态转换，则崩溃和挂起被认为是“unique”。<br>Crashes and hangs are considered “unique” if the associated execution paths involve any state transitions not seen in previously-recorded faults.<br>The file names for crashes and hangs are correlated with parent, non-faulting queue entries. This should help with debugging.<br>crash和hang的文件名与parent和非故障队列条目有关。这应该有助于调试。<br>当您无法重现由afl-fuzz发现的崩溃时，最可能的原因是您没有设置与该工具使用的内存限制相同。尝试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ LIMIT_MB=50</span><br><span class="line">$ ( ulimit -Sv $[LIMIT_MB &lt;&lt; 10]; /path/to/tested_binary ... )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>更改LIMIT_MB以匹配传递给afl-fuzz的-m参数。<br>任何现有输出目录也可用于恢复已中止的jobs；try：<br><code>$ ./afl-fuzz -i- -o existing_output_dir [...etc...]  //-i之后并没有输入目录，而是一个连接符，</code><br>如果您安装了gnuplot，您还可以使用afl-plot为任何活动的模糊任务生成一些漂亮的图形。</p>
<h2 id="并行Fuzzing"><a href="#并行Fuzzing" class="headerlink" title="并行Fuzzing"></a>并行Fuzzing</h2><p>afl-fuzz的每个实例都占用大约一个核心。 这意味着在多核系统上，并行化是必须的以充分利用硬件。 有关如何在多个内核或多个网络机器上fuzz一个共同目标的提示，请参阅parallel_fuzzing.txt。<br>并行Fuzzing模式还提供了一种用于将AFL与其他模糊器，符号执行或者concolic混合符号执行引擎等连接的简单方法;  请参阅parallel_fuzzing.txt的最后一节提示。<br>PS: -M  和 -S 参数</p>
<h1 id="Fuzzer-dictionaries字典"><a href="#Fuzzer-dictionaries字典" class="headerlink" title="Fuzzer dictionaries字典"></a>Fuzzer dictionaries字典</h1><p>(没试过，还不理解)<br>afl-fuzz变异引擎针对紧凑的数据格式（即，图像，多媒体，压缩数据，正则表达式语法或shell脚本）进行了优化。它有点不太适合特别冗长和冗余的语言 - 尤其包括HTML，SQL或JavaScript。<br>为了避免构建语法感知工具的麻烦，afl-fuzz提供了一种使用语言关键字，magic header或其他与目标数据类型相关联的特殊表示的可选字典为模糊过程提供种子的方法 - 并且使用它来重建底层语法,参考:<br><a href="http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html" target="_blank" rel="noopener">参考链接</a><br>要使用这个功能，首先需要创建在dictionaries/README.dictionaries中讨论的两种格式之一的字典；然后在命令行中使用-x选项将fuzzer指向它。（在该目录的子目录下已经提供了几个常用字典）<br>没有办法提供更多结构化的底层语法的描述，但是fuzzer可能会根据单独的插桩反馈来找出其中的一些。 参考：<br><a href="http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html" target="_blank" rel="noopener">http://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html</a><br>PS:即使当没有给出明确的字典时，afl-fuzz将通过在确定性字节翻转期间非常仔细地观察插桩来尝试提取输入语料库中的现有语法表示（token-表示，记号）。 这适用于一些类型的解析器和语法，但不像-x模式那么好。<br>如果字典真的很难得到，另一个选择是让AFL运行一段时间，然后使用AFL自带的表示捕获库。 有关详细信息，请参阅libtokencap/README.tokencap。<br><strong>在<a href="http://volatileminds.net/2015/08/20/advanced-afl-usage-preeny.html中有关于字典的使用和简单介绍。" target="_blank" rel="noopener">http://volatileminds.net/2015/08/20/advanced-afl-usage-preeny.html中有关于字典的使用和简单介绍。</a></strong></p>
<h2 id="crash分类Crash-triage"><a href="#crash分类Crash-triage" class="headerlink" title="crash分类Crash triage"></a>crash分类Crash triage</h2><p>基于覆盖的崩溃分组通常生成一个小数据集，可以手动或使用非常简单的GDB或Valgrind脚本快速分类。每个崩溃也可追溯到其在queue中的非崩溃的parent测试用例，从而更容易诊断故障。<br>afl-fuzz的支持一个崩溃探索模式，使用-C标志。<a href="https://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html" target="_blank" rel="noopener">https://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html</a><br>在这种模式下，模糊器需要一个或多个崩溃的测试用例作为输入，并使用其反馈驱动的fuzzing策略来快速枚举程序中可以到达的所有代码路径，同时保持其处于崩溃状态。<br>不导致崩溃的变异被拒绝; 任何不影响执行路径的更改也一样。<br>输出是一个小文件库，可以快速检查攻击者对故障地址的控制程度，或者是否有可能通过一个初始的越界读取，以及查看下面的内容 。<br>afl-tmin工具适用于crash和non-crash的test case。用于test case 最小化！注意：afl-tmin是对一个文件的无用字节、bit的删减以达到最小化。<br><code>$ ./afl-tmin -i test_case -o minimized_result -- /path/to/program [...]</code><br><em>afl-analyze工具。它需要一个输入文件，尝试顺序翻转字节，并观察被测试程序的行为。然后对输入进行颜色编码，基于哪些部分看起来是关键的，哪些部分不是;虽然不是防弹，它通常可以提供对复杂文件格式的快速洞察。</em><br>PS: 什么是防弹？？</p>
<h2 id="常识性的风险Common-sense-risks"><a href="#常识性的风险Common-sense-risks" class="headerlink" title="常识性的风险Common-sense risks"></a>常识性的风险Common-sense risks</h2><p>与其他计算密集型任务类似，fuzzing可能会给你的硬件或系统带来压力， A good way to monitor disk I/O on Linux is the ‘iostat’ command:<br><code>$ iostat -d 3 -x -k [...optional disk ID...]</code></p>
<h2 id="已知的限制和改进的领域Known-limitations-amp-areas-for-improvement"><a href="#已知的限制和改进的领域Known-limitations-amp-areas-for-improvement" class="headerlink" title="已知的限制和改进的领域Known limitations &amp; areas for improvement"></a>已知的限制和改进的领域Known limitations &amp; areas for improvement</h2><p> -AFL通过检查由于信号（SIGSEGV，SIGABRT等）导致的第一个引起的进程死亡来检测故障。为这些信号安装自定义处理程序的程序可能需要注释掉相关代码。同样，由目标产生的子处理中的错误可能会逃避检测，除非您手动添加一些代码来捕获它。<br>    -与任何其他强力工具一样，如果使用加密，校验和，加密签名或压缩来完全包装要测试的实际数据格式，则模糊器提供有限的覆盖率。<br>要解决这个问题，你可以注释掉相关的检查；如果这是不可能的，你也可以写一个后处理器postprocessor，参考experimental/post_library/。<br>-有一些不幸的折衷对于ASAN和64位二进制。这不是由于afl-fuzz的任何特定故障;请参阅notes_for_asan.txt提示。<br>-没有直接支持fuzzing网络服务，后台守护进程或需要UI交互工作的交互式应用程序。您可能需要进行简单的代码更改，以使它们以更传统的方式运行。Preeny可以提供一个相对简单的选项，看看：<br>  <a href="https://github.com/zardus/preeny" target="_blank" rel="noopener">https://github.com/zardus/preeny</a><br>有关修改基于网络的服务的一些有用的提示还可以在以下网址找到：https：//<a href="http://www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop" target="_blank" rel="noopener">www.fastly.com/blog/how-to-fuzz-server-american-fuzzy-lop</a><br>-AFL不输出人类可读的覆盖数据。如果你想监视覆盖，使用afl-cov从Michael Rash：<a href="https://github.com/mrash/afl-cov" target="_blank" rel="noopener">https://github.com/mrash/afl-cov</a><br>-偶尔，有意识的机器反对他们的创造者。如果发生这种情况，请参阅<a href="http://lcamtuf.coredump.cx/prep/。" target="_blank" rel="noopener">http://lcamtuf.coredump.cx/prep/。</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/07/afl-README-cn/" data-id="cjk8lemk0000248s35j51zflf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/26/jsonp/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          jsonp
        
      </div>
    </a>
  
  
    <a href="/2017/12/07/afl使用内存盘fuzz/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">afl使用内存盘fuzz</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPP/">GPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http代理/">http代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mestasploit/">mestasploit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞分析/">漏洞分析</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GPP/" style="font-size: 10px;">GPP</a> <a href="/tags/http代理/" style="font-size: 10px;">http代理</a> <a href="/tags/mestasploit/" style="font-size: 10px;">mestasploit</a> <a href="/tags/漏洞分析/" style="font-size: 20px;">漏洞分析</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/24/跨域方案枚举/">跨域方案枚举</a>
          </li>
        
          <li>
            <a href="/2018/03/24/免杀Powershell/">免杀Powershell</a>
          </li>
        
          <li>
            <a href="/2018/03/11/metasploit自动化攻击/">metasploit自动化攻击</a>
          </li>
        
          <li>
            <a href="/2018/03/08/VBScript挂马/">VBScript挂马</a>
          </li>
        
          <li>
            <a href="/2018/03/04/使用GPP漏洞进行域渗透/">使用GPP漏洞进行域渗透</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>